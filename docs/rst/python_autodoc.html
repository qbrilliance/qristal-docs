<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Python API &mdash; Qristal  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
      <link rel="stylesheet" type="text/css" href="../_static/styles/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-EML76VL6ZZ"></script>
        <script src="../_static/js/qb_ga.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Typedef qristal::StatePrepFuncCType" href="../_cpp_api/typedef_namespaceqristal_1a98d1e0a7b33b8dfb424b5f60b4a6d86a.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Qristal
              <img src="../_static/qb_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="backends.html">Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="emulator.html">Qristal Emulator Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqpu.html">Qristal Virtual QPU</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html">Noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html#user-defined-noise-models">User defined noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="parametrization.html">Parametrized Quantum Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe.html">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nextflow.html">Nextflow</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_gates.html">Quantum Gates</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source Code Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../_cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-session-class">The session class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-circuit-class">The Circuit class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#noise-modelling">Noise Modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#placement">Placement</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#noise-aware-placement">Noise-aware placement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#swap-based-placement">Swap-based placement</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Qristal</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Python API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rst/python_autodoc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="python-api">
<h1>Python API<a class="headerlink" href="#python-api" title="Permalink to this heading"></a></h1>
<section id="the-session-class">
<h2>The session class<a class="headerlink" href="#the-session-class" title="Permalink to this heading"></a></h2>
<p>The <cite>session</cite> class provides a way to set up the experiment table.</p>
<p>You can use the experiment table to run a list of quantum circuits under different conditions, such as number of measurement shots, backends, parameters, etc.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.session">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">session</span></span><a class="headerlink" href="#core.session" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="core.session.all_bitstring_counts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_bitstring_counts</span></span><a class="headerlink" href="#core.session.all_bitstring_counts" title="Permalink to this definition"></a></dt>
<dd><p>all_bitstring_counts:</p>
<p>After calling session.run(), the counts from running sn shots are stored in a list of shot counts.
The indices of this list correspond to the different possible base-2 bitstring solutions, with the mapping from bitstring to list index provided by the function bitstring_index.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.all_bitstring_probabilities">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_bitstring_probabilities</span></span><a class="headerlink" href="#core.session.all_bitstring_probabilities" title="Permalink to this definition"></a></dt>
<dd><p>all_bitstring_probabilities:</p>
<p>The probability distribution from running sn shots stored in a list of solution output probabilities, provided after calling session.run() with <cite>calc_gradients</cite> set True.
The indices of this list correspond to the different possible base-2 bitstring solutions, with the mapping from bitstring to list index provided by the function bitstring_index.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.all_bitstring_probability_gradients">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_bitstring_probability_gradients</span></span><a class="headerlink" href="#core.session.all_bitstring_probability_gradients" title="Permalink to this definition"></a></dt>
<dd><p>all_bitstring_probability_gradients:</p>
<p>The probability Jacobians from running sn shots, after calling session.run() with <cite>calc_gradients</cite> set True.
The Jacobian is an array of gradients of the probability of each bitstring combination with respect to the runtime parameters,
in the following format (where y is the list of probabilities and x is the parameter list):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\frac{dy_0}{dx_0} &amp; \frac{dy_0}{dx_1} &amp; ... &amp; \frac{dy_0}{dx_n} \\
\frac{dy_1}{dx_0} &amp; \frac{dy_1}{dx_1} &amp; ... &amp; \frac{dy_1}{dx_n} \\
... \\
\frac{dy_m}{dx_0} &amp; \frac{dy_m}{dx_1} &amp; ... &amp; \frac{dy_m}{dx_n}
\end{bmatrix}\end{split}\]</div>
<p>As the Jacobian is returned as a list-of-lists, it can be accessed in row major format, and indexing the above matrix can be done accordingly, i.e. all_bitstring_probability_gradients()[0][1] corresponds to the dy_0/dx_1 value.
The entry x_i corresponds to the ith parameter in the parameter list (i.e. the parameters ordered by their first appearance in the circuit.)
The entry y_i is the output probability of ith bitstring, indexed in the same manner as the all_bitstring_counts. Explicitly, the index i corresponding to a specific bitstring can be obtained by calling bitstring_index(bitstring), with bitstring given as a list of bit values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.bitstring_index">
<span class="sig-name descname"><span class="pre">bitstring_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.session.bitstring_index" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>bitstring_index(self: core.session, arg0: core.VectorBool) -&gt; int</p>
<blockquote>
<div><p>Get the (base-10) integer index for the counts/probabilities list, corresponding to a specific output state specified by a list of bit values.</p>
</div></blockquote>
</li>
<li><p>bitstring_index(self: core.session, arg0: numpy.ndarray[bool]) -&gt; int</p>
<blockquote>
<div><p>Get the (base-10) integer index for the counts/probabilities list, corresponding to a specific output state specified by a list of bit values.</p>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.draw_shot">
<span class="sig-name descname"><span class="pre">draw_shot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">core.VectorBool</span></span></span><a class="headerlink" href="#core.session.draw_shot" title="Permalink to this definition"></a></dt>
<dd><p>draw_shot : Draw a single shot from the saved results of circuit i, condition j.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.gpu_device_ids">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gpu_device_ids</span></span><a class="headerlink" href="#core.session.gpu_device_ids" title="Permalink to this definition"></a></dt>
<dd><p>gpu_device_ids:</p>
<p>Set list of GPU device IDs to use with GPU-enabled backends.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.irtarget">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">irtarget</span></span><a class="headerlink" href="#core.session.irtarget" title="Permalink to this definition"></a></dt>
<dd><p>Circuit object to be executed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise_model</span></span><a class="headerlink" href="#core.session.noise_model" title="Permalink to this definition"></a></dt>
<dd><p>Circuit object to be executed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.num_threads">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads</span></span><a class="headerlink" href="#core.session.num_threads" title="Permalink to this definition"></a></dt>
<dd><p>The number of threads in the Qristal thread pool</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>num_threads</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.one_qubit_gate_depths">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">one_qubit_gate_depths</span></span><a class="headerlink" href="#core.session.one_qubit_gate_depths" title="Permalink to this definition"></a></dt>
<dd><p>one_qubit_gate_depths:</p>
<p>After calling session.run(), get the number of single qubit gates applied to each qubit, using a dictionary where the keys are integers corresponding to qubit indices.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qbjson">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qbjson</span></span><a class="headerlink" href="#core.session.qbjson" title="Permalink to this definition"></a></dt>
<dd><p>qbjson:</p>
<p>Get the output QB JSON string sent to QB hardware, after calling session.run().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qobj">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qobj</span></span><a class="headerlink" href="#core.session.qobj" title="Permalink to this definition"></a></dt>
<dd><p>qobj:</p>
<p>Retrieve the input passed to the aer simulator backend in .qobj JSON format, after calling session.run().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.results">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">results</span></span><a class="headerlink" href="#core.session.results" title="Permalink to this definition"></a></dt>
<dd><p>results:</p>
<p>After calling session.run(), the counts from running sn shots are stored in a dictionary of shot counts. The dictionary keys are bit lists of length qn, with the same bit indexation as the processor registers.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.results_native">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">results_native</span></span><a class="headerlink" href="#core.session.results_native" title="Permalink to this definition"></a></dt>
<dd><p>results_native:</p>
<p>An additional results container holding the native measurement results if automatic SPAM correction was enabled in session.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.run" title="Permalink to this definition"></a></dt>
<dd><p>Execute quantum circuit synchronously (blocking).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run_async">
<span class="sig-name descname"><span class="pre">run_async</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">core.Handle</span></span></span><a class="headerlink" href="#core.session.run_async" title="Permalink to this definition"></a></dt>
<dd><p>Execute quantum circuit asynchronously (non-blocking).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run_with_SPAM">
<span class="sig-name descname"><span class="pre">run_with_SPAM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.run_with_SPAM" title="Permalink to this definition"></a></dt>
<dd><p>Automatically execute a SPAM measurement and enable automatic SPAM correction. Then automatically exexute run().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.state_vec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">state_vec</span></span><a class="headerlink" href="#core.session.state_vec" title="Permalink to this definition"></a></dt>
<dd><p>state_vec:</p>
<p>Get the full complex state vector – works with qpp and aer statevector backends only!</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.timing_estimates">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">timing_estimates</span></span><a class="headerlink" href="#core.session.timing_estimates" title="Permalink to this definition"></a></dt>
<dd><p>timing_estimates:</p>
<p>After calling session.run(), get estimated circuit execution times on hardware, in ms.</p>
<dl class="simple">
<dt>Keys (integers):</dt><dd><p>0: Total time
1: Initialisation component
2: Gate (max. depth) component
3: Readout component
4: Total time (from classical simulation)
5: PC transfer to controller time</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.transpiled_circuit">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">transpiled_circuit</span></span><a class="headerlink" href="#core.session.transpiled_circuit" title="Permalink to this definition"></a></dt>
<dd><p>transpiled_circuit:</p>
<p>Retrieve the transpiled version of the executed circuit after calling session.run().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.two_qubit_gate_depths">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">two_qubit_gate_depths</span></span><a class="headerlink" href="#core.session.two_qubit_gate_depths" title="Permalink to this definition"></a></dt>
<dd><p>two_qubit_gate_depths:</p>
<p>After calling session.run(), get the number of two qubit gates applied to each qubit, using a dictionary where the keys are integers corresponding to qubit indices.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.z_op_expectation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">z_op_expectation</span></span><a class="headerlink" href="#core.session.z_op_expectation" title="Permalink to this definition"></a></dt>
<dd><p>z_op_expectation:</p>
<p>After calling session.run(), get the output expected value in the Z basis, from the shot counts observed.</p>
</dd></dl>

</dd></dl>

</section>
<section id="the-circuit-class">
<h2>The Circuit class<a class="headerlink" href="#the-circuit-class" title="Permalink to this heading"></a></h2>
<p>The <cite>Circuit</cite> class represents a quantum circuit, i.e., an ordered sequence of [quantum gates and measurements](<a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/quantum_computing.html">https://qristal.readthedocs.io/en/latest/rst/quantum_computing.html</a>).</p>
<p>In addition to elementary gates, it also supports pre-built circuit templates for commonly-used algorithms, such as Quantum Fourier Transform (QFT), algebraic circuits, etc.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.Circuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">Circuit</span></span><a class="headerlink" href="#core.Circuit" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.amcu">
<span class="sig-name descname"><span class="pre">amcu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_control</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.amcu" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Multi Controlled Unitary With Ancilla</p>
</div></blockquote>
<p>This method decomposes a multi-controlled unitary into Toffoli gates
and the unitary itself, with the use of ancilla qubits. With N control
qubits there should be N-1 ancilla. The resulting instructions are added
to the circuit (AMCU gate).</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>U</strong> The unitary operation [CircuitBuilder]</p></li>
<li><p><strong>qubits_control</strong> The indices of the control qubits [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> The indices of the ancilla qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.amplitude_amplification">
<span class="sig-name descname"><span class="pre">amplitude_amplification</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.amplitude_amplification" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Amplitude Amplification</p>
</div></blockquote>
<p>This method adds a number of Grovers operators to the circuit.</p>
<p>Grovers operators are used to amplify the amplitude of some desired
subspace of your quantum state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>power</strong> The number of Grovers operators to append to the circuit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.append" title="Permalink to this definition"></a></dt>
<dd><p>Append the ‘other’ quantum circuit to this circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.canonical_ae">
<span class="sig-name descname"><span class="pre">canonical_ae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grover_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.canonical_ae" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Canonical Amplitude Estimation</p>
</div></blockquote>
<p>This method adds the canonical version of Quantum Amplitude Estimation
(QAE) to the circuit.</p>
<p>Given a quantum state split into a good subspace and a bad subspace,
the QAE sub-routine provides a k-bit approximation to the amplitude of
the good subspace, a.</p>
<p>QAE works by using the Grovers operator Q, which amplifies the amplitude
of the good subspace, as the unitary input to a Quantum Phase Estimation
routine.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>grover_op</strong> The circuit for the Grovers operator Q for the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>no_state_prep</strong> If true, assumes the state is already prepared in the appropriate register [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ccx">
<span class="sig-name descname"><span class="pre">ccx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ccx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Toffoli gate</p>
</div></blockquote>
<p>This method adds a Toffoli gate (CCX) to the circuit.</p>
<p>The CCX gate performs an X gate on the target qubit
conditional on the two control qubits being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx1</strong> the index of the first control qubit [int]</p></li>
<li><p><strong>ctrl_idx2</strong> the index of the second control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ch">
<span class="sig-name descname"><span class="pre">ch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ch" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CH gate</p>
</div></blockquote>
<p>This method adds a controlled-H (CH) gate to the circuit.</p>
<p>The CH gate performs an H gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cnot">
<span class="sig-name descname"><span class="pre">cnot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.cnot" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CNOT gate</p>
</div></blockquote>
<p>This method adds a controlled-X (CNOT) gate to the circuit.</p>
<p>The CNOT gate performs an X gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.comparator">
<span class="sig-name descname"><span class="pre">comparator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_qubit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.comparator" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Comparator</p>
</div></blockquote>
<p>This method adds a quantum bit string comparator to the circuit.</p>
<p>The quantum bit string comparator is used to compare the values of two
bit string. If the trial score is greater than the best score, the flag
qubit is flipped.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>best_score</strong> The score we are comparing strings to [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits used to encode the scores [int]</p></li>
<li><p><strong>trial_score_qubits</strong> The indices of the qubits encoding the trial states [list of int]</p></li>
<li><p><strong>flag_qubit</strong> The index of the flag qubit which is flipped whenever trial score &gt; BestScore [int]</p></li>
<li><p><strong>best_score_qubits</strong> The indices of the qubits encoding the BestScore value [list of int]</p></li>
<li><p><strong>ancilla_qubits</strong> The indices of the ancilla qubits required for the comparator circuit, if num_scoring_qubits = N we need 3N-1 ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.comparator_as_oracle">
<span class="sig-name descname"><span class="pre">comparator_as_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_qubit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.comparator_as_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Comparator as Oracle</p>
</div></blockquote>
<p>This method adds a quantum bit string comparator oracle to the circuit.</p>
<p>The quantum bit string comparator is used to add a negative phase to any
trial state whose bit string value is greater than the state being
compared to. In this way it can be used as an oracle in a Grovers
operator that amplifies higher scoring strings. This may be useful in
many search problems.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>best_score</strong> The score we are comparing strings to [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits used to encode the scores [int]</p></li>
<li><p><strong>trial_score_qubits</strong> The indices of the qubits encoding the trial states [list of int]</p></li>
<li><p><strong>flag_qubit</strong> The index of the flag qubit which acquires a negative phase whenever trial score &gt; BestScore [int]</p></li>
<li><p><strong>best_score_qubits</strong> The indices of the qubits encoding the BestScore value [list of int]</p></li>
<li><p><strong>ancilla_qubits</strong> The indices of the ancilla qubits required for the comparator circuit, if num_scoring_qubits = N we need 3N-1 ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.compare_beam_oracle">
<span class="sig-name descname"><span class="pre">compare_beam_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.compare_beam_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Compare Beam Oracle</p>
</div></blockquote>
<p>This method adds a compare beam oracle to the circuit.</p>
<p>This method is required for the quantum decoder algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.compare_gt">
<span class="sig-name descname"><span class="pre">compare_gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_flag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.compare_gt" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Compare Greater Than</p>
</div></blockquote>
<p>This method adds a greater-than comparator to the circuit.</p>
<p>Given two binary strings a and b, this comparator flips a flag qubit
whenever a&gt;b. This method uses far less ancilla than the more general
comparator method provided.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> The indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> The indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubit_flag</strong> The index of the flag qubit that is flipped whenever a&gt;b [int]</p></li>
<li><p><strong>qubit_ancilla</strong> The index of the single ancilla qubit required [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_multiplication">
<span class="sig-name descname"><span class="pre">controlled_multiplication</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_multiplication" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Multiplication</p>
</div></blockquote>
<p>This method adds a controlled Multiplication to the circuit.</p>
<p>Performs a Multiplication operation on a and b if an only if the
controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubits_result</strong> the indices of the qubits that will ecode the multiplication result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_proper_fraction_division">
<span class="sig-name descname"><span class="pre">controlled_proper_fraction_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_proper_fraction_division" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Proper Fraction Division</p>
</div></blockquote>
<p>This method adds a controlled proper fraction division to the circuit.</p>
<p>Performs a PFD operation on a and b if an only if the controls are
satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_numerator</strong> the indices of the qubits encoding the numerator [list of int]</p></li>
<li><p><strong>qubits_denominator</strong> the indices of the qubits encoding the denominator [list of int]</p></li>
<li><p><strong>qubits_fraction</strong> the indices of the qubits that will ecode the division result [list of int]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_ripple_carry_adder">
<span class="sig-name descname"><span class="pre">controlled_ripple_carry_adder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_adder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_sum</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_overflow</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_ripple_carry_adder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Addition</p>
</div></blockquote>
<p>This method adds a controlled ripple carry adder to the circuit.</p>
<p>Performs a RippleAdd operation on adder_bits and sum_bits if and only
if the controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_adder</strong> the indices of the qubits encoding adder_bits [list of int]</p></li>
<li><p><strong>qubits_sum</strong> the indices of the qubits encoding sum_bits [list of int]</p></li>
<li><p><strong>c_in</strong> the index of the carry-in bit [int]</p></li>
<li><p><strong>flags_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>flags_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>no_overflow</strong> Indicates that the total of the addition can be encoded on the same number of qubits as sum_bits without overflowing [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_subtraction">
<span class="sig-name descname"><span class="pre">controlled_subtraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_larger</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_smaller</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_subtraction" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Subtraction</p>
</div></blockquote>
<p>This method adds a controlled subtraction to the circuit.</p>
<p>Performs a subtraction operation on a and b if an only if the
controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_larger</strong> the indices of the qubits encoding the larger value [list of int]</p></li>
<li><p><strong>qubits_smaller</strong> the indices of the qubits encoding the smaller value [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_swap">
<span class="sig-name descname"><span class="pre">controlled_swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_swap" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled SWAP</p>
</div></blockquote>
<p>This method adds a controlled SWAP to the circuit.</p>
<p>Performs a SWAP operation on a and b if an only if the controls are
satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>flags_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>flags_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></span><a class="headerlink" href="#core.Circuit.copy" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cphase">
<span class="sig-name descname"><span class="pre">cphase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.cphase" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>cphase(self: core.Circuit, ctrl_idx: int, target_idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CPhase gate</p>
</div></blockquote>
<p>This method adds a controlled-U1 (CPhase) gate to the circuit.</p>
<p>The CPHase gate performs a U1(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>cphase(self: core.Circuit, ctrl_idx: int, target_idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CPhase gate</p>
</div></blockquote>
<p>This method adds a controlled-U1 (CPhase) gate with a free parameter ”
“to the circuit.</p>
<p>The CPHase gate performs a U1(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.crx">
<span class="sig-name descname"><span class="pre">crx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.crx" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>crx(self: core.Circuit, ctrl_idx: int, target_idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRX gate</p>
</div></blockquote>
<p>The CRX gate performs a RX(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>crx(self: core.Circuit, ctrl_idx: int, target_idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRX gate</p>
</div></blockquote>
<p>This method adds a controlled parameterized z-axis rotation (CRX) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cry">
<span class="sig-name descname"><span class="pre">cry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.cry" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>cry(self: core.Circuit, ctrl_idx: int, target_idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRY gate</p>
</div></blockquote>
<p>The CRY gate performs a RY(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>cry(self: core.Circuit, ctrl_idx: int, target_idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRY gate</p>
</div></blockquote>
<p>This method adds a controlled parameterized z-axis rotation (CRY) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.crz">
<span class="sig-name descname"><span class="pre">crz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.crz" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>crz(self: core.Circuit, ctrl_idx: int, target_idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRZ gate</p>
</div></blockquote>
<p>This method adds a controlled-U1 (CPhase) gate to the circuit.</p>
<p>The CRZ gate performs a RZ(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>crz(self: core.Circuit, ctrl_idx: int, target_idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>CRZ gate</p>
</div></blockquote>
<p>This method adds a controlled parameterized z-axis rotation (CRZ) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cz">
<span class="sig-name descname"><span class="pre">cz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.cz" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CZ gate</p>
</div></blockquote>
<p>This method adds a controlled-Z (CZ) gate to the circuit.</p>
<p>The CZ gate performs a Z gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.efficient_encoding">
<span class="sig-name descname"><span class="pre">efficient_encoding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_init_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_integer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.efficient_encoding" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Efficient Encoding</p>
</div></blockquote>
<p>This method adds an efficient encoding routine to the circuit.</p>
<p>Given a lookup function f that assigns a score to each binary string,
we entangle each string to its score. Rather than
encoding states sequentially we cut down on the
amount of X gates required by instead following the Gray code ordering
of states.</p>
<p>This module can optionally also flag strings of a certain value.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>scoring_function</strong> A function that inputs the integer value of a binary string and outputs its score [func(int) -&gt; int]</p></li>
<li><p><strong>num_state_qubits</strong> The number of qubits encoding the strings [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits encoding the scores [int]</p></li>
<li><p><strong>state_qubits</strong> The indices of the qubits encoding the strings [list of int]</p></li>
<li><p><strong>scoring_qubits</strong> The indices of the qubits encoding the scores [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>use_ancilla</strong> Indicates that ancilla qubits can be used to decompose MCX gates [bool]</p></li>
<li><p><strong>qubits_init_flag</strong> The indices of any flag qubits [list of int]</p></li>
<li><p><strong>flag_integer</strong> The integer value of binary strings that should be flagged [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.equality_checker">
<span class="sig-name descname"><span class="pre">equality_checker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.equality_checker" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Equality Checker</p>
</div></blockquote>
<p>This method adds an equality checker to the circuit.</p>
<p>Given two input bitstrings a and b the equality checker is
used to flip a flag qubit whenever a=b.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>flag</strong> the index of the flag qubit that gets flipped whenever a=b [int]</p></li>
<li><p><strong>use_ancilla</strong> Indicates that ancilla qubits can be used to decompose MCX gates [bool]</p></li>
<li><p><strong>qubits_ancilla</strong> The indices of the qubits to be used as ancilla qubits if use_ancilla=true [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">QPU</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_SHOTS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_QUBITS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.execute" title="Permalink to this definition"></a></dt>
<dd><p>Run the circuit.</p>
<p>This method is used to pass the circuit to an accelerator backend
for execution.</p>
<p>The optional parameters are:</p>
<ul class="simple">
<li><p><strong>QPU</strong> The accelerator name [string]</p></li>
<li><p><strong>NUM_SHOTS</strong> The number of shots to use [int]</p></li>
<li><p><strong>NUM_QUBITS</strong> The number of qubits required for the circuit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.exponent">
<span class="sig-name descname"><span class="pre">exponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_exponent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_significance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#core.Circuit.exponent" title="Permalink to this definition"></a></dt>
<dd><p>Exponent Base 2</p>
<p>This method adds an exponent to the circuit. This is used to replace some value
by its exponent base 2.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_log</strong> the indices of the qubits encoding the original value [list of int]</p></li>
<li><p><strong>qubits_exponent</strong> the indices of the qubits used to store the result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the indices of the required ancilla qubits [list of int]</p></li>
<li><p><strong>min_significance</strong> the accuracy cutoff [int]</p></li>
<li><p><strong>is_LSB</strong> indicates LSB ordering is used [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.exponential_search">
<span class="sig-name descname"><span class="pre">exponential_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#core.Circuit.exponential_search" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Exponential Search</p>
</div></blockquote>
<p>This method sets up and executes the exponential search routine.</p>
<p>Exponential search is a way to perform amplitude estimation when the
size of the “good” subspace is unknown (so the number of Grovers
operators to use is unknown).</p>
<p>We implement three variants:
- canonical exponential search is a specific “guess and check” method
- MLQAE exponential search uses MLQAE to first estimate the size of the good subspace then perform regular amplitude estimation with the appropriate number of Grovers operators
- CQAE exponential search uses canonical QAE to first estimate the size of the good subspace then perform regular amplitude estimation with the appropriate number of Grovers operators</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>method</strong> indicates which method to use. Options are “canonical”, “MLQAE”, “CQAE” [string]</p></li>
<li><p><strong>state_prep</strong> a function which produces the state prep circuit [StatePrepFuncCType]</p></li>
<li><p><strong>oracle</strong> a function which produces the oracle circuit that marks the good subspace [OracleFuncCType]</p></li>
<li><p><strong>best_score</strong> the current best score [int]</p></li>
<li><p><strong>f_score</strong> a function that returns a 1 if the input binary string has value greater than the current best score and 0 otherwise [func(int)-&gt;int]</p></li>
<li><p><strong>total_num_qubits</strong> total number of qubits [int]</p></li>
<li><p><strong>qubits_string</strong> the indices of the qubits encoding the strings [list of int]</p></li>
<li><p><strong>total_metric</strong> the indices of the qubits encoding the string scores after any required pre-processing of qubits_metric (required by decoder) [list of int]</p></li>
<li><p><strong>qpu</strong> the name of the accelerator used to execute the algorithm [string]</p></li>
</ul>
<p>Returns: a better score if found, otherwise returns the current best
score</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.generalised_mcx">
<span class="sig-name descname"><span class="pre">generalised_mcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.generalised_mcx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Generalised MCX</p>
</div></blockquote>
<p>This method adds a generalised MCX gate to the circuit.</p>
<p>By generalised MCX we mean that we allow the control qubits to be
conditional on being off or conditional on being on.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>target</strong> The index of the target qubit [int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.h" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Hadamard gate</p>
</div></blockquote>
<p>This method adds a Hadamard (H) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.inverse_circuit">
<span class="sig-name descname"><span class="pre">inverse_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">circ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.inverse_circuit" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Inverse Circuit</p>
</div></blockquote>
<p>This method adds the inverse of a circuit to the current circuit.</p>
<p>Given some collection of unitary operations,</p>
<p>U = U_NU_{N-1}…U_2U_1</p>
<p>this method appends the inverse to the circuit:</p>
<p>U^{-1} = U_1dg U_2dg…U_{N-1}dg U_Ndg</p>
<p>This may be useful for un-computing ancilla or for constructing Grovers
operators.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>circ</strong> The circuit whose inverse we want to add to the current circuit [CircuitBuilder]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.iqft">
<span class="sig-name descname"><span class="pre">iqft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.iqft" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Inverse Quantum Fourier Transform</p>
</div></blockquote>
<p>This method adds the inverse of the Quantum Fourier Transform (IQFT) to
the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits</strong> the indices of the target qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.mcx">
<span class="sig-name descname"><span class="pre">mcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.mcx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>MCX gate</p>
</div></blockquote>
<p>This method adds a multi-controlled X (MCX) gate to the circuit.</p>
<p>The MCX gate performs an X gate on the target qubit
conditional on all control qubits being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_inds</strong> the indices of the control qubits [list of int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.measure" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Measurement</p>
</div></blockquote>
<p>This method is used to indicate a qubit in the circuit should be
measured.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit to be measured [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.measure_all">
<span class="sig-name descname"><span class="pre">measure_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_QUBITS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.measure_all" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Measure all qubits</p>
</div></blockquote>
<p>This method adds a measurement for all qubits involved in the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>NUM_QUBITS</strong> the number of qubits in the circuit [int] [optional, the default value of -1 becomes the output of the XACC nPhysicalBits method.]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.multiplication">
<span class="sig-name descname"><span class="pre">multiplication</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.multiplication" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Multiplication</p>
</div></blockquote>
<p>This method adds a Multiplication to the circuit.</p>
<p>Given two inputs a and b, computes the product a*b and stores the result on a new register.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubits_result</strong> the indices of the qubits that will ecode the multiplication result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.num_free_params">
<span class="sig-name descname"><span class="pre">num_free_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#core.Circuit.num_free_params" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of free parameters in the (parametrized) circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.num_qubits">
<span class="sig-name descname"><span class="pre">num_qubits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#core.Circuit.num_qubits" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of (physical) qubits in the circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.openqasm">
<span class="sig-name descname"><span class="pre">openqasm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.openqasm" title="Permalink to this definition"></a></dt>
<dd><p>Get the OpenQASM representation of the (non-parametrized) circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.param_dict_to_list">
<span class="sig-name descname"><span class="pre">param_dict_to_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.Circuit.param_dict_to_list" title="Permalink to this definition"></a></dt>
<dd><p>Convert a dictionary that defines parameter assignments to a vector for
input to the session object. The vector will be ordered according to
the definition of the free parameter in the circuit; for example, if
a gate is defined with the free parameter “alpha” in an empty circuit,
its mapped parameter will be at index 0 in the vector. If another gate
exists in this circuit with the parameter “beta”, the value for this
mapped parameter will be at index 1, and so on.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>param_dict</strong> the dictionary</p></li>
</ul>
<p>Returns:</p>
<p>A vector containing the ordered parameter values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.print" title="Permalink to this definition"></a></dt>
<dd><p>Print the quantum circuit that has been built</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.proper_fraction_division">
<span class="sig-name descname"><span class="pre">proper_fraction_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.proper_fraction_division" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Proper Fraction Division</p>
</div></blockquote>
<p>This method adds a proper fraction division to the circuit.</p>
<p>Given two inputs num and denom, calculates num/denom and stores the result in a new register, assuming denom &gt; num</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_numerator</strong> the indices of the qubits encoding the numerator [list of int]</p></li>
<li><p><strong>qubits_denominator</strong> the indices of the qubits encoding the denominator [list of int]</p></li>
<li><p><strong>qubits_fraction</strong> the indices of the qubits that will ecode the division result [list of int]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.q_prime_unitary">
<span class="sig-name descname"><span class="pre">q_prime_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_ancilla_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_ancilla_letter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_next_letter_probabilities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_next_letter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.q_prime_unitary" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Q’ Unitary</p>
</div></blockquote>
<p>This method adds a Q’ unitary to the circuit.</p>
<p>Q’ is a unitary required for the quantum decoder algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.qft">
<span class="sig-name descname"><span class="pre">qft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.qft" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Quantum Fourier Transform</p>
</div></blockquote>
<p>This method adds the Quantum Fourier Transform (QFT) to the circuit.
This is a quantum analogue of the discrete Fourier Transform.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits</strong> the indices of the target qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.qpe">
<span class="sig-name descname"><span class="pre">qpe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.qpe" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Quantum Phase Estimation</p>
</div></blockquote>
<p>This method adds the Quantum Phase Estimation (QPE) sub-routine to the
circuit.</p>
<p>Given some unitary operator U and and eigenvector v of U, QPE is used to provide a k-bit approximation to
the corresponding eigenvalue’s phase, storing the result in an evaluation register whilst leaving the eigenvector
unchanged.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>oracle</strong> The unitary operator U involved in the QPE routine [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the phase [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits encoding the eigenvector of the unitary [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits that will be used to store the approximate phase [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ripple_add">
<span class="sig-name descname"><span class="pre">ripple_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">carry_bit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ripple_add" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Ripple Carry Adder</p>
</div></blockquote>
<p>This method adds a ripple carry adder to the circuit.</p>
<p>The ripple carry adder is an efficient in-line addition operation
with a carry-in bit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>a</strong> The qubit indices of the first register in the addition [list of int]</p></li>
<li><p><strong>b</strong> The qubit indices of the second register in the addition. This is where the result of a+b will be stored [list of int]</p></li>
<li><p><strong>carry_bit</strong> The index of the carry-in bit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_MLQAE">
<span class="sig-name descname"><span class="pre">run_MLQAE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_in_good_subspace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_runs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_MLQAE" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Maximum-Likelihood Amplitude Estimation</p>
</div></blockquote>
<p>This method sets up and executes an instance of the maximum-likelihood
amplitude estimation circuit.</p>
<p>Given a state split into a good subspace and a bad subspace, MLQAE is an alternative to canonical QAE to find an estimate for the
amplitude of the good subspace, a. It works by performing several runs
of amplitude amplification with various iterations and recording the
number of good shots measured. Given this data, it finds the value of
a that maximises the likelihood function.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>is_in_good_subspace</strong> A function that, given a measured bitstring and potentially some other input value, returns a 1 if the measurement is in the good subspace and a 0 otherwise. [func(str, int) -&gt; int]</p></li>
<li><p><strong>score_qubits</strong> The indices of the qubits that determine whether the state is in the good or bad subspace [list of int]</p></li>
<li><p><strong>total_num_qubits</strong> The total number of qubits in the circuit [int]</p></li>
<li><p><strong>num_runs</strong> The number of runs of amplitude amplification (~4-6 is usually sufficient)</p></li>
<li><p><strong>shots</strong> The number of shots in each run [int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_canonical_ae">
<span class="sig-name descname"><span class="pre">run_canonical_ae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grover_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_canonical_ae" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Canonical Amplitude Estimation</p>
</div></blockquote>
<p>This method sets up and executes an instance of the canonical amplitude
estimation circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>grover_op</strong> The circuit for the Grovers operator Q for the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_canonical_ae_with_oracle">
<span class="sig-name descname"><span class="pre">run_canonical_ae_with_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_canonical_ae_with_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Canonical Amplitude Estimation with Oracle</p>
</div></blockquote>
<p>This method sets up and executes an instance of the canonical amplitude
estimation circuit, but instead of providing the grovers_op Q, we
provide the oracle circuit O which marks the good elements.</p>
<p>The Grovvers operator Q is then constructed within the method from O and
the state_prep circuit A.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.rx">
<span class="sig-name descname"><span class="pre">rx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.rx" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>rx(self: core.Circuit, idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RX gate</p>
</div></blockquote>
<p>This method adds an x-axis rotation (RX) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the x-axis [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>rx(self: core.Circuit, idx: int, name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RX gate</p>
</div></blockquote>
<p>This method adds an x-axis rotation (RX) gate with a free parameter ”
“to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ry">
<span class="sig-name descname"><span class="pre">ry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.ry" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>ry(self: core.Circuit, idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RY gate</p>
</div></blockquote>
<p>This method adds a y-axis rotation (RY) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the y-axis [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>ry(self: core.Circuit, idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RY gate</p>
</div></blockquote>
<p>This method adds a y-axis rotation (RY) gate with a free parameter ”
“to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.rz">
<span class="sig-name descname"><span class="pre">rz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.rz" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>rz(self: core.Circuit, idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RZ gate</p>
</div></blockquote>
<p>This method adds a z-axis rotation (RZ) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the z-axis [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>rz(self: core.Circuit, idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>RZ gate</p>
</div></blockquote>
<p>This method adds a z-axis rotation (RZ) gate with a free parameter ”
“to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.s">
<span class="sig-name descname"><span class="pre">s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.s" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>S gate</p>
</div></blockquote>
<p>This method adds an S gate to the circuit.</p>
<p>The S gate is defined by its action on the basis states</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.sdg">
<span class="sig-name descname"><span class="pre">sdg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.sdg" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sdg gate</p>
</div></blockquote>
<p>This method adds an inverse of the S gate (Sdg) to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.subtraction">
<span class="sig-name descname"><span class="pre">subtraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_larger</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_smaller</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.subtraction" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Subtraction</p>
</div></blockquote>
<p>This method adds a subtraction to the circuit.</p>
<p>Given two inputs a and b, leaves b unchanged but maps a to the difference a-b, assuming a&gt;b.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_larger</strong> the indices of the qubits encoding the larger value [list of int]</p></li>
<li><p><strong>qubits_smaller</strong> the indices of the qubits encoding the smaller value [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.superposition_adder">
<span class="sig-name descname"><span class="pre">superposition_adder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.Circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q0:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_flags:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_string:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_metric:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ae_state_prep_circ:</span> <span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_beam_metric:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.superposition_adder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Superposition adder</p>
</div></blockquote>
<p>This method adds a Superposition Adder to the circuit.</p>
<p>Given a superposition state, this circuit computes the mean of the amplitudes of the superposition components.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>q0</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>q1</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>q2</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>qubits_flags</strong> the indices of the flag qubits [list of int]</p></li>
<li><p><strong>qubits_string</strong> the indices of the qubits encoding the string [list of int]</p></li>
<li><p><strong>qubits_metric</strong> the indices of the qubits encoding the metric value corresponding to the string [list of int]</p></li>
<li><p><strong>ae_state_prep_circ</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>qubits_ancilla</strong> the indices of the required ancilla qubits [list of int]</p></li>
<li><p><strong>qubits_beam_metric</strong> the indices of the qubits encoding class’ metric [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.swap">
<span class="sig-name descname"><span class="pre">swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.swap" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>SWAP gate</p>
</div></blockquote>
<p>This method adds a SWAP gate to the circuit. The SWAP gate is used to swap the quantum state of two qubits.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>q1</strong> the index of the first qubit [int]</p></li>
<li><p><strong>q2</strong> the index of the second qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.t">
<span class="sig-name descname"><span class="pre">t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.t" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>T gate</p>
</div></blockquote>
<p>This method adds a T gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.tdg">
<span class="sig-name descname"><span class="pre">tdg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.tdg" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Tdg gate</p>
</div></blockquote>
<p>This method adds an inverse of the T gate (Tdg) to the circuit.</p>
<p>The Tdg gate is defined by its action on the basis states</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.u1">
<span class="sig-name descname"><span class="pre">u1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.u1" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>u1(self: core.Circuit, idx: int, theta: float) -&gt; None</p>
<blockquote>
<div><blockquote>
<div><p>U1 gate</p>
</div></blockquote>
<p>This method adds a phase (U1) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>u1(self: core.Circuit, idx: int, param_name: str) -&gt; None</p>
<blockquote>
<div><p>U1 gate</p>
<p>This method adds a phase (U1) gate with a free parameter ”
“to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>name</strong> the name of the free parameter [string]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.u3">
<span class="sig-name descname"><span class="pre">u3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.Circuit.u3" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>u3(self: core.Circuit, idx: int, param_1: str, param_2: str, param_3: str) -&gt; None</p>
<blockquote>
<div><p>Parameterized U3 gate
U3 gate</p>
<p>This method adds an arbitrary parametrized single qubit gate (U3) to the circuit, shown as U at <a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/quantum_gates.html">https://qristal.readthedocs.io/en/latest/rst/quantum_gates.html</a>
Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>param_1</strong> the name of the 1st free parameter (theta) [string]</p></li>
<li><p><strong>param_2</strong> the name of the 2nd free parameter (phi) [string]</p></li>
<li><p><strong>param_3</strong> the name of the 3rd free parameter (lambda) [string]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>u3(self: core.Circuit, idx: int, theta: float, phi: float, lambda: float) -&gt; None</p>
<blockquote>
<div><p>U3 gate</p>
<p>This method adds an arbitrary single qubit gate (U3) to the circuit, shown as U at <a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/quantum_gates.html">https://qristal.readthedocs.io/en/latest/rst/quantum_gates.html</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> [double]</p></li>
<li><p><strong>phi</strong> [double]</p></li>
<li><p><strong>lambda</strong> [double]</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.x" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Pauli-X gate</p>
</div></blockquote>
<p>This method adds a Pauli-X (X) gate to the circuit.</p>
<p>The X gate is defined by its action on the basis states</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong><strong>int</strong><strong>]</strong> (<em>- idx the index of the qubit being acted on</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.y" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Pauli-Y gate</p>
</div></blockquote>
<p>This method adds a Pauli-Y (Y) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.z">
<span class="sig-name descname"><span class="pre">z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.z" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Pauli-Z gate</p>
</div></blockquote>
<p>This method adds a Pauli-Z (Z) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

</dd></dl>

</section>
<section id="noise-modelling">
<h2>Noise Modelling<a class="headerlink" href="#noise-modelling" title="Permalink to this heading"></a></h2>
<p>QB Qristal allows an end-user to implement noise models in Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">NoiseModel</span></span><a class="headerlink" href="#core.NoiseModel" title="Permalink to this definition"></a></dt>
<dd><p>Noise model class allowing specification of noise parameters and connectivity for each gate.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseModel.QubitConnectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QubitConnectivity</span></span><a class="headerlink" href="#core.NoiseModel.QubitConnectivity" title="Permalink to this definition"></a></dt>
<dd><p>Type of qubit connectivity</p>
<p>Members:</p>
<blockquote>
<div><p>AllToAll</p>
<p>Custom</p>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.QubitConnectivity.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#core.NoiseModel.QubitConnectivity.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.add_gate_error">
<span class="sig-name descname"><span class="pre">add_gate_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.NoiseModel.add_gate_error" title="Permalink to this definition"></a></dt>
<dd><p>Add a gate error channel for a gate operation</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>noise_channel</em> Noise channel to be associated with the gate [List(KrausOperator)]</p></li>
<li><p><em>gate_name</em> Name of the gates [String]</p></li>
<li><p><em>qubits</em> Qubit indices of the gate. [List(Integer)]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.add_qubit_connectivity">
<span class="sig-name descname"><span class="pre">add_qubit_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.NoiseModel.add_qubit_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Add a connected qubit pair to the topology model</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q1</em> First qubit index [Integer]</p></li>
<li><p><em>q2</em> Second qubit index [Integer]</p></li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.connectivity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">connectivity</span></span><a class="headerlink" href="#core.NoiseModel.connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Get connectivity as a list of connected qubit pairs</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#core.NoiseModel.name" title="Permalink to this definition"></a></dt>
<dd><p>The colloquial name of the noise model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.qobj_basis_gates">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qobj_basis_gates</span></span><a class="headerlink" href="#core.NoiseModel.qobj_basis_gates" title="Permalink to this definition"></a></dt>
<dd><p>The list of basis gates that the AER QObj will be referring to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.qobj_compiler">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qobj_compiler</span></span><a class="headerlink" href="#core.NoiseModel.qobj_compiler" title="Permalink to this definition"></a></dt>
<dd><p>‘xacc-qobj’ | ‘qristal-qobj’.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The name of the QObj compiler to use with the AER simulator. Valid options</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.set_qubit_readout_error">
<span class="sig-name descname"><span class="pre">set_qubit_readout_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.ReadoutError" title="core.ReadoutError"><span class="pre">core.ReadoutError</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.NoiseModel.set_qubit_readout_error" title="Permalink to this definition"></a></dt>
<dd><p>Set the qubit readout error</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>qubitIdx</em> Qubit to set [Integer]</p></li>
<li><p><em>ro_error</em> Readout error [ReadoutError]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.NoiseModel.to_json" title="Permalink to this definition"></a></dt>
<dd><p>Convert noise model to json string</p>
</dd></dl>

</dd></dl>

<p>This <cite>NoiseModel</cite> can be constructed from the quantum device <cite>NoiseProperties</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseProperties">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">NoiseProperties</span></span><a class="headerlink" href="#core.NoiseProperties" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Use NoiseProperties to accept user input parameters for custom noise models.  There are 3 types of inputs used for constructing a custom noise model:</dt><dd><ul class="simple">
<li><p>Qubit topology</p></li>
<li><p>Time duration of quantum gate operations</p></li>
<li><p>Parameters for quantum noise channels and classical errors</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.gate_pauli_errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gate_pauli_errors</span></span><a class="headerlink" href="#core.NoiseProperties.gate_pauli_errors" title="Permalink to this definition"></a></dt>
<dd><p><cite>gate_pauli_errors</cite> is the parameter for gate error derived from randomized benchmarking of a quantum gate operation that is applied at a target set of qubits.</p>
<p>Unit: none (range: [0.0, 1.0])</p>
<p>Code example: 4 qubits: “u3” single-qubit gate, uniform gate error parameter = 0.03 (3%); “cx” between neighboring qubits (on a line), gate error parameter = 0.1 (10%):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">num_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.03</span>
<span class="w">  </span><span class="cp"># Qubits on a line:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">num_qubits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span>

<span class="cp"># Print out the gate error map:</span>
<span class="n">print</span><span class="p">(</span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.gate_time_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gate_time_us</span></span><a class="headerlink" href="#core.NoiseProperties.gate_time_us" title="Permalink to this definition"></a></dt>
<dd><p><cite>gate_time_us</cite> is the duration for a quantum gate operation when applied at a target set of qubits.</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits: “u3” single-qubit gate, uniform duration of 5.2us; “cx” between neighboring qubits (on a line), uniform duration of 20us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">num_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.2</span>
<span class="w">  </span><span class="cp"># Qubits on a line:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">num_qubits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span>

<span class="cp"># Print out the gate time map:</span>
<span class="n">print</span><span class="p">(</span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.qubit_topology">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qubit_topology</span></span><a class="headerlink" href="#core.NoiseProperties.qubit_topology" title="Permalink to this definition"></a></dt>
<dd><p><cite>qubit_topology</cite> is a graph comprised of directed edges {control qubit, target qubit} with control qubit as the source of the edge -&gt; target qubit as the destination of the edge.</p>
<p>Code example: “cx” symmetrical two-qubit gate with 4 qubits in the topology below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Topology</span>
<span class="cp">#    q0 &lt;--cx--&gt; q1</span>
<span class="cp">#     ^           ^</span>
<span class="cp">#     |           |</span>
<span class="cp">#     cx          cx</span>
<span class="cp">#     |           |</span>
<span class="cp">#     v           v</span>
<span class="cp">#    q3 &lt;--cx--&gt; q2</span>
<span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">qubit_topology</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.readout_errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">readout_errors</span></span><a class="headerlink" href="#core.NoiseProperties.readout_errors" title="Permalink to this definition"></a></dt>
<dd><p><cite>readout_errors</cite> is the <em>classical readout error</em> (off-diagonal elements of the confusion matrix).</p>
<p>For a qubit register, with individual qubits zero-indexed by i, <cite>readout_errors</cite> is a map from qubit[i] -&gt; <cite>ReadoutError[i]</cite>.</p>
<p>Unit: none (quantities are probabilities).</p>
<p>Code example: 4-qubit device: 2 qubits (Q0 and Q1) with p(0|1) = p(1|0) = 0.05,
2 qubits (Q2 and Q3) with p(0|1) = 0.1 and p(1|0) = 0.08:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnpro_balanced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadoutError</span><span class="p">()</span>
<span class="n">t_qbnpro_balanced</span><span class="p">.</span><span class="n">p_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05</span>
<span class="n">t_qbnpro_balanced</span><span class="p">.</span><span class="n">p_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05</span>
<span class="n">t_qbnpro_asym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadoutError</span><span class="p">()</span>
<span class="n">t_qbnpro_asym</span><span class="p">.</span><span class="n">p_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.10</span>
<span class="n">t_qbnpro_asym</span><span class="p">.</span><span class="n">p_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.08</span>
<span class="cp"># Q0 and Q1 readout errors</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_balanced</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_balanced</span>
<span class="cp"># Q2 and Q3 readout errors</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_asym</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_asym</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.t1_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t1_us</span></span><a class="headerlink" href="#core.NoiseProperties.t1_us" title="Permalink to this definition"></a></dt>
<dd><p><span class="math notranslate nohighlight">\(T_1\)</span> is the <em>qubit relaxation time</em>.</p>
<p>For a qubit register, with individual qubits zero-indexed by <cite>i</cite>; <cite>t1_us</cite> is a map from qubit[i] -&gt; T1[i].</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits all with T1 = 1.5us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="cp"># Set T1 of qubits (all with 1.5 us)</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">t1_us</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">1.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.t2_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t2_us</span></span><a class="headerlink" href="#core.NoiseProperties.t2_us" title="Permalink to this definition"></a></dt>
<dd><p><span class="math notranslate nohighlight">\(T_2\)</span> is the <em>qubit dephasing time</em>.</p>
<p>For a qubit register, with individual qubits zero-indexed by <cite>i</cite>; <cite>t2_us</cite> is a map from qubit[i] -&gt; T2[i].</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits all with T2 = 0.15us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="cp"># Set T2 of qubits (all with 0.15 us)</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">t2_us</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.15</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<p>Additionally, users can use these builtin classes to construct commonly-used noise channels when building the <cite>NoiseModel</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.AmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">AmplitudeDampingChannel</span></span><a class="headerlink" href="#core.AmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Amplitude damping channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.AmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.AmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.PhaseDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">PhaseDampingChannel</span></span><a class="headerlink" href="#core.PhaseDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Phase damping channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.PhaseDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.PhaseDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.DepolarizingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">DepolarizingChannel</span></span><a class="headerlink" href="#core.DepolarizingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Depolarizing channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.DepolarizingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.DepolarizingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>Create(self: int, arg0: float) -&gt; list[core.KrausOperator]</p>
<blockquote>
<div><p>Create single-qubit depolarizing channel (balanced/symmetric)</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit index</p></li>
<li><p><em>p</em> Total depolarizing probability</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Create(self: int, arg0: int, arg1: float) -&gt; list[core.KrausOperator]</p>
<blockquote>
<div><p>Create two-qubit depolarizing channel (balanced/symmetric)</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q1</em> First qubit</p></li>
<li><p><em>q2</em> Second qubit</p></li>
<li><p><em>p</em> Total depolarizing probability</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.GeneralizedPhaseAmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">GeneralizedPhaseAmplitudeDampingChannel</span></span><a class="headerlink" href="#core.GeneralizedPhaseAmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Single-qubit combined phase and amplitude damping quantum error channel</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.GeneralizedPhaseAmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.GeneralizedPhaseAmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Create a generalized amplitude and phase damping channel</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit</p></li>
<li><p><em>excited_state_population</em> Excited state population</p></li>
<li><p><em>param_amp</em> Amplitude damping parameter</p></li>
<li><p><em>param_phase</em> Phase damping parameter</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.GeneralizedAmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">GeneralizedAmplitudeDampingChannel</span></span><a class="headerlink" href="#core.GeneralizedAmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Generalized amplitude damping quantum error channel</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.GeneralizedAmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.GeneralizedAmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Create a generalized amplitude damping channel</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit</p></li>
<li><p><em>excited_state_population</em> Excited state population</p></li>
<li><p><em>param_amp</em> Amplitude damping parameter</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.ReadoutError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">ReadoutError</span></span><a class="headerlink" href="#core.ReadoutError" title="Permalink to this definition"></a></dt>
<dd><p>Probabilities of reading out a value for a qubit that does not reflect its true state.</p>
<dl class="py property">
<dt class="sig sig-object py" id="core.ReadoutError.p_01">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_01</span></span><a class="headerlink" href="#core.ReadoutError.p_01" title="Permalink to this definition"></a></dt>
<dd><p>Classical probability of detecting 0 whereas the true state was <span class="math notranslate nohighlight">\(|1\rangle\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.ReadoutError.p_10">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_10</span></span><a class="headerlink" href="#core.ReadoutError.p_10" title="Permalink to this definition"></a></dt>
<dd><p>Classical probability of detecting 1 whereas the true state was <span class="math notranslate nohighlight">\(|0\rangle\)</span></p>
</dd></dl>

</dd></dl>

<p>In case no builtin noise channels are available for your use case, a fully-customized noise channel can be constructed in terms of instances of the <cite>KrausOperator</cite> class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.KrausOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">KrausOperator</span></span><a class="headerlink" href="#core.KrausOperator" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="core.KrausOperator.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#core.KrausOperator.matrix" title="Permalink to this definition"></a></dt>
<dd><p>Kraus matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.KrausOperator.qubits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qubits</span></span><a class="headerlink" href="#core.KrausOperator.qubits" title="Permalink to this definition"></a></dt>
<dd><p>Qubits that this Kraus operator acts on.</p>
</dd></dl>

</dd></dl>

</section>
<section id="placement">
<h2>Placement<a class="headerlink" href="#placement" title="Permalink to this heading"></a></h2>
<p>Qristal contains placement methods to perform mapping from program (logical) qubits to device (physical) qubits satisfying qubit connectivity constraints.</p>
<section id="noise-aware-placement">
<h3>Noise-aware placement<a class="headerlink" href="#noise-aware-placement" title="Permalink to this heading"></a></h3>
<p>The <cite>noise_aware_placement_pass</cite> takes into account gate error rates and readout errors to find the best placement map.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.noise_aware_placement_pass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">noise_aware_placement_pass</span></span><a class="headerlink" href="#core.noise_aware_placement_pass" title="Permalink to this definition"></a></dt>
<dd><p>The noise_aware_placement_pass class uses device connectivity, gate errors (1-q and 2-q) and readout errors to find the best placement map.</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.noise_aware_placement_pass.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.noise_aware_placement_pass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit:</span> <span class="pre">qristal::CircuitBuilder</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.noise_aware_placement_pass.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply noise-aware placement on the input circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>circuit</strong> – Circuit to be placed (map qubit indices and inject SWAP gates as necessary)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Device configuration for the noise-aware placement is defined by <cite>noise_aware_placement_config</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.noise_aware_placement_config">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">noise_aware_placement_config</span></span><a class="headerlink" href="#core.noise_aware_placement_config" title="Permalink to this definition"></a></dt>
<dd><p>The noise_aware_placement_config class encapsulates generic backend information required by the noise-aware placement pass.</p>
</dd></dl>

</section>
<section id="swap-based-placement">
<h3>Swap-based placement<a class="headerlink" href="#swap-based-placement" title="Permalink to this heading"></a></h3>
<p>The <cite>swap_placement_pass</cite> performs circuit placement by swapping qubits (along the shortest possible path) when there are gates between uncoupled qubits.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.swap_placement_pass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">swap_placement_pass</span></span><a class="headerlink" href="#core.swap_placement_pass" title="Permalink to this definition"></a></dt>
<dd><p>Circuit placement pass based on injection of SWAP gates to satisfy device connectivity topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.swap_placement_pass.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.swap_placement_pass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit:</span> <span class="pre">qristal::CircuitBuilder</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.swap_placement_pass.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply SWAP-based placement on the input circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>circuit</strong> – Circuit to be placed (map qubit indices and inject SWAP gates as necessary)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../_cpp_api/typedef_namespaceqristal_1a98d1e0a7b33b8dfb424b5f60b4a6d86a.html" class="btn btn-neutral float-left" title="Typedef qristal::StatePrepFuncCType" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Quantum Brilliance Pty Ltd.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>